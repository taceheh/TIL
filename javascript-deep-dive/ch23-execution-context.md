# [JS] 23장. 실행 컨텍스트 (Execution Context)

## 1. 실행 컨텍스트란? (Definition)
> "자바스크립트의 코드가 평가되고 실행되는 환경이자, 실행에 필요한 모든 정보를 관리하는 영역"

- **핵심 키워드**: `실행 컨텍스트 스택`, `렉시컬 환경`, `환경 레코드`, `소스코드의 평가와 실행`
- 책에 나오는 MDN 정의만 적지 말고, **내가 이해한 문장**으로 한 줄 요약을 꼭 적어보세요.
  - 코드를 실행하려면 변수, 스코프, this, 실행 순서 등 수많은 재료가 필요한데, 이 모든 것을 모아두고 관리하는 "자바스크립트 엔진의 핵심 관리자(Manager)" 객체이다.\
    
<br>

## 2. 핵심 전제 지식 (Prerequisites)
실행 컨텍스트를 이해하려면 자바스크립트 엔진이 코드를 처리하는 독특한 과정을 먼저 알아야 함.

### 2.1 소스코드의 평가와 실행 (Evaluation vs Execution)
- **개념**: 자바스크립트 엔진은 코드를 한 번에 실행하지 않고, **[평가]**와 **[실행]**이라는 2단계를 거침.
1. **평가** : 선언문(var, function 등)만 쏙 뽑아서 먼저 실행. 이때 생성된 변수나 함수 식별자를 실행 컨텍스트(렉시컬 환경)에 등록한다. (호이스팅의 원인)
2. **실행** : 선언문을 제외한 코드를 한 줄씩 순차적으로 실행(런타임). 변수 값을 할당하거나 함수를 호출

### 2.2 실행 컨텍스트 스택 (Call Stack)
- **정의** : 생성된 실행 컨텍스트들의 실행 순서를 관리하는 스택(Stack) 자료구조.
- **핵심** : 코드가 실행되면 컨텍스트가 스택에 Push되고, 종료되면 Pop되어 제거 (LIFO: Last In First Out)
- **흐름** : 전역 코드 평가/실행 -> 함수 호출(Push) -> 함수 종료(Pop) -> 전역 종료(Pop).

<br>

## 3. 실행 컨텍스트의 동작 원리 (Mechanism)
### 3.1 렉시컬 환경 (Lexical Environment)

- **정의**: 식별자(변수 이름)와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조.
- **구성 요소**: 환경 레코드 (Environment Record): 식별자를 등록하고 값을 관리하는 저장소 (창고).<br>외부 렉시컬 환경에 대한 참조 (Outer Reference): 상위 스코프를 가리키는 포인터 (연결 고리).


### 3.2 동작 과정 (Flow)

1. **평가** : 함수가 호출되면 실행 컨텍스트를 생성하고, 내부의 환경 레코드에 매개변수와 지역 변수(선언만)를 등록함.
2. **참조 결정** : Outer Reference에 자신이 정의된 위치(상위 스코프)의 렉시컬 환경 참조값을 할당하여 스코프 체인을 연결함.
3. **실행** : 코드를 실행하며 환경 레코드의 변수 값을 업데이트하거나 읽어옴.

<br>

## 4. 실행 컨텍스트의 세부 구조 (Structure Details)

### 4.1 전역 환경 레코드 (Global Environment Record)
- **특징**: var 키워드와 let/const 키워드를 관리하는 공간이 분리되어 있음.
- **객체 환경 레코드** : var로 선언한 전역 변수와 함수 선언문 등은 BindingObject를 통해 전역 객체(window)의 프로퍼티가 됨.
- **선언적 환경 레코드** : let, const로 선언한 전역 변수는 별도의 선언적 공간에 존재하여 window로 접근할 수 없음.

  
### 4.2 함수 환경 레코드 (Function Environment Record)
함수 내부의 매개변수, arguments 객체, 함수 내부 지역 변수를 관리함.<br>전역과 달리 let, const, var 구분 없이 하나의 레코드에서 관리됨.

<br>

## 5. 자주 발생하는 실수 (Common Mistakes)
var의 전역 객체 바인딩 관련 내용

```
var x = 1;
const y = 2;

console.log(window.x); // 1
console.log(window.y); // undefined
```

### 왜 const는 window에 없을까?

1. **var의 동작** : 전역 환경 레코드의 **'객체 환경 레코드'**에 등록되며, 이는 전역 객체(window)와 연결됨.
2. **let/const의 동작** : 전역 환경 레코드의 **'선언적 환경 레코드'**라는 별도 공간에 등록됨. 이 공간은 전역 객체와 연결되지 않음.
3. **결론** : 최신 자바스크립트에서는 전역 변수 사용을 지양해야 하지만, 원리를 알면 window 프로퍼티 오염 문제를 이해할 수 있음.

<br>


## 6. 헷갈렸던 부분 & 의문점
### 6.1 호이스팅과 실행 컨텍스트
- **Q.** 호이스팅이 "변수를 위로 끌어올리는 것"이라고만 알고 있었는데, 내부 원리가 뭘까?
- **A.** 물리적으로 코드를 옮기는 게 아니라, **'소스코드 평가 단계'**에서 변수 식별자를 미리 환경 레코드에 등록해버리기 때문에 발생하는 현상이다. 실행 단계(런타임)에서는 이미 변수가 등록되어 있으니 참조가 가능한 것.

### 6.2 스코프 체인의 실체

- **Q.** 스코프 체인은 어떻게 상위 변수를 찾나?
- **A.** 행 컨텍스트 내부에 있는 **Outer Lexical Environment Reference**를 타고 올라간다.<br>현재 레코드에 없으면 -> Outer가 가리키는 상위 레코드로 이동 -> 없으면 또 이동 -> 전역까지 이동. (단방향 링크드 리스트)

### 6.3. TDZ (Temporal Dead Zone)의 원인
- **Q.** let은 왜 호이스팅이 안 되는 것처럼 보일까?
- **A.** 실행 컨텍스트에 등록은 되지만(호이스팅 됨), var와 달리 **'초기화'**가 평가 단계에서 이루어지지 않기 때문이다. 선언문이 나올 때까지 접근을 막아두는 구간(TDZ)이 존재한다.
