# [JS] 24장. 클로저 (Closure)

## 1. 클로저란? (Definition)
> "함수가 선언된 렉시컬 환경을 기억하여, 함수가 스코프 밖에서 실행될 때도 그 환경에 접근할 수 있는 것"

- **핵심 키워드**: `렉시컬 스코프`, `실행 컨텍스트`, `가비지 컬렉터(GC)`
- 책에 나오는 MDN 정의만 적지 말고, **내가 이해한 문장**으로 한 줄 요약을 꼭 적어보세요.
  - 변수나 함수의 유효 범위와 같은 공간의 개념보다 그 공간을 **"어떤 기준으로 연결할 것인가?"** 에 대한 **규칙(Rule)** 에 가까운 것 같다.
    
<br>

## 2. 핵심 전제 지식 (Prerequisites)
클로저는 아래 두 가지 자바스크립트의 특성이 결합되어 나타나는 현상

### 2.1 렉시컬 스코프 (Lexical Scope)
- **정의**: 함수를 어디서 **호출**했는지가 아니라, 어디서 **정의**했는지에 따라 상위 스코프를 결정하는 것. (다른 말로 '정적 스코프'라고도 함)
- **핵심**: 자바스크립트는 렉시컬 스코프를 따르므로, 함수가 정의되는 시점에 상위 스코프가 정적으로 결정되고 변하지 않음.

> [💾 예제 코드 실행해보기](./examples/24-01-lexical-scope.js)

- **결과**: 둘 다 1이 출력
- **이유**: bar 함수는 전역에서 정의. 따라서 bar의 상위 스코프는 전역 스코프. foo 안에서 호출되었다고 해서 상위 스코프가 foo로 바뀌지 않음.

### 2.2 함수 객체의 내부 슬롯 `[[Environment]]`
함수 정의가 평가되어 함수 객체가 생성되는 시점에, **현재 실행 중인 실행 컨텍스트의 렉시컬 환경(상위 스코프)** 을 [[Environment]] 내부 슬롯에 저장하여 기억

### 2.3 렉시컬 스코프의 동작 원리 (Mechanism)
1. **객체 선언** : 함수가 정의될 때, **현재 실행 중인 렉시컬 환경(상위 스코프)** 의 참조값이 함수 객체의 [[Environment]] 내부 슬롯에 저장
2. **호출** : 함수가 호출되면 실행 컨텍스트가 생성되고, 그 안에 **새로운 렉시컬 환경이 '생성'**, 함수 내부의 변수들이 이 환경(레코드)에 저장
3. **참조** : 방금 만든 **새로운 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조(Link)'** 를 결정할 때, 아까 1번에서 [[Environment]]에 저장해뒀던 그 값을 가져와서 연결

<br>

## 3. 클로저의 동작 원리 (Mechanism)
### 3.1 핵심 질문과 답변

- **Q**: 외부 함수가 종료(pop)되어 콜 스택에서 사라졌는데, 어떻게 내부 함수가 외부 함수의 변수를 참조할 수 있을까?
- **A**: 실행 컨텍스트는 사라져도, 렉시컬 환경은 사라지지 않기 때문

<br>

### 3.2 메커니즘 설명

**1단계: 참조의 연결과 콜 스택 제거**

- 외부 함수(outer)가 종료되면 외부 함수의 실행 컨텍스트는 콜 스택에서 제거(Pop)됨

**2단계: 렉시컬 환경의 독립적 존재**

- 실행 컨텍스트가 제거되었다고 해서 그 안에 있던 렉시컬 환경(메모리 공간)까지 즉시 파괴되는 것은 아님

**3단계: 가비지 컬렉터의 생존 규칙**

- 자바스크립트의 가비지 컬렉터(Garbage Collector)는 다음의 원칙을 준수함
- **"누군가가 참조하고 있는 메모리 공간은 절대 해제하지 않는다"**

**4단계: 렉시컬 환경의 생존 이유**

- 내부 함수(inner)가 외부 함수의 렉시컬 환경을 자신의 [[Environment]]로 참조하고 있음
- 이 내부 함수가 전역 변수 등에 의해 참조되고 있다면
- 외부 함수의 렉시컬 환경은 **"사용 중"** 인 상태로 간주됨
- 따라서 힙(Heap) 메모리에 계속 살아있게 됨


<br>

## 4. 클로저의 활용 사례 (Use Cases)

### 4.1 상태 유지 (State Maintenance)
- **개념**: 현재 상태를 안전하게 유지하고, 상태가 의도치 않게 변경되지 않도록 특정 함수에게만 상태 변경 권한 부여

> [💾 예제 코드 실행해보기](./examples/24-02-counter.js)

- **해설** : num 변수는 increase 함수(클로저)만이 변경 가능. 전역 변수로 만들었을 때 누군가 실수로 `num = 100`으로 변경하는 부작용(Side Effect)을 원천 차단
  
### 4.2 정보 은닉 (Information Hiding)
- **개념**: 외부에서 접근할 필요가 없거나 접근하면 안 되는 세부 구현 내용(변수, 메서드)을 감추는 기법 (캡슐화의 일종)

- **설명**: 자바스크립트는 과거에 private 키워드가 없었기 때문에, 클로저를 통해 "외부에서는 안 보이지만 내부에서는 조작 가능한" private 변수를 구현함
  - 참고: 최신 모던 자바스크립트(ES2019+)에서는 클래스의 #private 필드를 주로 사용하지만, 리액트의 Hooks(useState 등)는 여전히 클로저의 정보 은닉 원리를 기반으로 동작합니다.

## 5. 자주 발생하는 실수 (Common Mistakes)
책 후반부에 나오는 `var`와 `for`문 예제

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () { return i; };
}
```

### 왜 3, 3, 3이 나올까?

**1단계: var의 스코프 문제**

- var i는 블록 레벨 스코프가 아니라 함수 레벨 스코프를 준수
- 따라서 for문의 코드 블록 { ... }은 스코프를 생성하지 않음
- 즉, i는 전역 변수처럼 취급됨

**2단계: 참조의 시점**

- 배열 안에 담긴 3개의 함수는 모두 같은 전역 변수 i를 바라봄(참조)

**3단계: 함수 실행 시점**

- 함수가 실행(funcs[j]())되는 시점은 이미 for 루프가 완료되어 i가 3이 된 이후임

**4단계: 최종 결과**

- 3개의 함수 모두 "지금 i 값 내놔!"라고 하니, 전부 3을 가져옴

### 해결 방법

```javascript
var funcs = [];

for (let i = 0; i < 3; i++) { // var -> let으로 변경
  funcs[i] = function () { return i; };
}

// 결과: 0, 1, 2
```

**이유**

- let은 블록 레벨 스코프를 준수
- for 문이 반복될 때마다 새로운 렉시컬 환경(새로운 스코프)이 생성됨
- 각 함수는 서로 다른 스코프(각각의 i=0, i=1, i=2가 저장된 공간)를 기억하게 됨
- 따라서 올바른 값을 출력함

<br>



### 6.2 가비지 컬렉터(GC) 동작 방식
- **의문:** 함수가 끝나면 내부 변수는 다 지워져야 하는 거 아닌가? 왜 살아있지?
- **이해:** 가비지 컬렉터는 **"누군가 참조하고 있는 메모리"**는 지우지 않는다. 내부 함수가 외부 함수의 변수를 잡고 있고, 그 내부 함수가 밖으로 반환되어 어딘가에서 쓰이고 있다면(참조된다면), GC는 그 환경을 지우지 않는다.
