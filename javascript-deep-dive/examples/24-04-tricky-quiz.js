/**
 * [JS] 클로저 심화 퀴즈 & 동작 원리 분석
 * * 이 파일은 클로저의 동작 원리(실행 컨텍스트, 스코프 체인)를 
 * 깊이 있게 이해하기 위한 3가지 대표 예제입니다.
 */

// =================================================================
// Quiz 1. 비동기와 스코프 (var의 함정)
// =================================================================

function question1() {
  // var i는 블록 스코프가 아닌 '함수 레벨 스코프'를 가집니다.
  // 즉, 이 함수 내에서 i라는 변수 공간은 딱 하나만 존재합니다.
  for (var i = 1; i <= 3; i++) {
    setTimeout(function () {
      console.log(i);
    }, 1000);
  }
}

question1();

/**
 * [정답 및 해설]
 * * - 출력 결과: 4, 4, 4 (1초 뒤 동시에 출력)
 * * [동작 원리 분석]
 * 1. 동기 처리 (Loop): 
 * - for문은 매우 빠르게 실행되어 순식간에 끝납니다.
 * - 이때 setTimeout의 콜백 함수들은 브라우저의 타이머(Web API)에 등록만 되고 실행되지 않습니다.
 * - 반복문이 종료되는 순간, 변수 i의 값은 이미 4(3에서 ++된 상태)가 되어 있습니다.
 * * 2. 비동기 처리 (Callback):
 * - 1초 뒤, 태스크 큐에 있던 콜백 함수들이 콜 스택으로 들어와 실행됩니다.
 * - console.log(i)가 실행되면서 i를 찾습니다.
 * - 이때 i는 이미 4로 변해있는 상위 스코프의 변수를 참조합니다.
 * - var는 변수를 공유하기 때문에, 모든 콜백 함수가 같은 i(값: 4)를 바라봅니다.
 */


// =================================================================
// Quiz 2. 공유된 렉시컬 환경 (상태 공유)
// =================================================================

function makeCounter() {
  let num = 0; // 자유 변수 (Free Variable)
  
  // 객체를 반환하면서 increase, decrease 함수가 생성됨
  return {
    increase: function () {
      num++;
      console.log('up:', num);
    },
    decrease: function () {
      num--;
      console.log('down:', num);
    }
  };
}

const counter = makeCounter();
counter.increase();
counter.increase();
counter.decrease();
counter.increase();

/**
 * [정답 및 해설]
 * * - 출력 결과: up: 1 -> up: 2 -> down: 1 -> up: 2
 * - 최종 값: 2
 * * [동작 원리 분석]
 * 1. 렉시컬 환경 생성:
 * - makeCounter 함수가 호출될 때 하나의 실행 컨텍스트와 '렉시컬 환경'이 생성됩니다.
 * - 이곳에 num = 0 상태가 저장됩니다.
 * * 2. 내부 슬롯 [[Environment]]의 참조:
 * - increase와 decrease 함수는 같은 makeCounter 실행 컨텍스트 안에서 태어났습니다.
 * - 따라서 두 함수 객체의 [[Environment]] 내부 슬롯은 '동일한 렉시컬 환경(num이 있는 곳)'을 가리킵니다.
 * * 3. 상태 공유:
 * - 두 함수는 같은 메모리 공간(렉시컬 환경)을 참조하므로, 
 * increase가 num을 변경하면 decrease도 변경된 num을 바라봅니다.
 * - 이를 통해 전역 변수 없이도 상태를 안전하게 공유하고 유지할 수 있습니다.
 */


// =================================================================
// Quiz 3. 스코프 체인과 섀도잉 (우선순위)
// =================================================================

let name = 'Global'; // 전역 변수

function outer() {
  let name = 'Outer'; // 외부 함수 변수
  
  // 매개변수 name을 받는 내부 함수
  return function inner(name) { 
    console.log(name);
  };
}

const myFunc = outer();
myFunc('Local'); 

/**
 * [정답 및 해설]
 * * - 출력 결과: 'Local'
 * * [동작 원리 분석]
 * 1. 식별자 검색 (Identifier Resolution):
 * - console.log(name)이 실행될 때, 자바스크립트 엔진은 name이라는 변수를 찾기 시작합니다.
 * * 2. 스코프 체인 탐색 순서:
 * - 1순위: 현재 실행 중인 inner 함수의 렉시컬 환경 (매개변수 name 포함) -> 발견! ('Local')
 * - 2순위: 상위 스코프 outer 함수의 렉시컬 환경 ('Outer') -> 검색 안 함
 * - 3순위: 전역 스코프 ('Global') -> 검색 안 함
 * * 3. 변수 섀도잉 (Variable Shadowing):
 * - 더 가까운 스코프(inner)에 있는 변수(매개변수)가 
 * 상위 스코프(outer, Global)에 있는 같은 이름의 변수를 가려버리는 현상입니다.
 * - 따라서 상위 변수값은 무시되고 'Local'이 출력됩니다.
 */
